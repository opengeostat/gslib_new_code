module gslib
    use, intrinsic:: ieee_arithmetic, only: ieee_value, ieee_quiet_nan, ieee_is_nan
    implicit none

    !General constants
    real, parameter, public :: EPSLON=1.0e-20, PI=3.14159265,PMX=999., DEG2RAD=3.141592654/180.0
    
    integer, parameter, public :: VARTYPE_CATEGORICAL = 0
    integer, parameter, public :: VARTYPE_CONTINOUS = 1

    !CDF parameter for beyond
    integer, parameter, public :: CDF_TAIL_LINEAR = 1
    integer, parameter, public :: CDF_TAIL_POWER = 2
    integer, parameter, public :: CDF_TAIL_TABULATED = 3
    integer, parameter, public :: CDF_TAIL_HYPERBOLIC = 4   

    !Variogram Models for COVA3
    integer, parameter, public :: COV_SPHERICAL = 1
    integer, parameter, public :: COV_EXPONENTIAL = 2
    integer, parameter, public :: COV_GAUSSIAN = 3
    integer, parameter, public :: COV_POWER = 4
    integer, parameter, public :: COV_HOLE_EFFECT = 5
    integer, parameter, public :: COV_DAMP_HOLE_EFFECT = 5   

    ! constants for random generator lcg
    integer, parameter :: i64 = selected_int_kind(18)
    integer(i64), parameter :: m_lcg = 2147483648_i64
    integer, parameter :: a_lcg = 1103515245
    integer, parameter :: c_lcg = 12345

    contains

        ! NOTE: use LAPACK as replacement for ksol.f90 and ktsol.f90 
        !       to compile
        !        a) install openblas precompiled. with conda use 
        !           > conda install -c conda-forge openblas
        !        b) just link the library. here an example 
        !           > gfortran -o .\test.exe .\test.f90 -L "OpenBLAS-0.3.15" "C:\Users\AMartinez\Miniconda3\pkgs\openblas-0.3.15-pthreads_h543f93c_0\Library\lib\openblas.lib"

        pure integer(i64) function lcg(x)
            !-----------------------------------------------------------------------
            !                 Linear congruential generator 
            !              ******************************************
            ! Implements a thread safe linear congruential random generator 
            ! that uses glib (GCC) parameters:
            !   mlcgrand        modulus 2^31, or 2147483648
            !   a               multiplier 1103515245
            !   c               increment 12345
            ! as defined in https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
            !
            ! To generate a sequence of random numbers:
            !   a) select an initial state (x[0] = seed)
            !   b) run lcgrand(x[0]) to get x[1]
            !   c) to get the next random number pass the current state x[n-1], in other words
            !       x[n] = lcgrand(x[n-1])
            ! please note that here [] denote array, not coarray
            !
            ! the output is a sequence of integers in the inteval ]0, m[
            ! to get uniform numbers divide by the modulus, for example x/2^31, or use function ulcg()
            ! Note that you have to keep a copy of the previous state x[n-1],
            !
            ! see also: https://rosettacode.org/wiki/Linear_congruential_generator#Fortran
            !
            ! INPUT VARIABLES:
            !   x                integer of 64 bits (i64) with the state of the previous 
            !                    random number in the sequence
            ! OUTPUT
            !   x[n+1]           integer of 64 bits (i64) with the state of the next 
            !                    random number in the sequence
            !-----------------------------------------------------------------------

            ! inputs
            integer(i64), intent(in) :: x

            ! interbal variables defined globally

            lcg = mod(a_lcg * x + c_lcg, m_lcg)

        end function lcg

        pure elemental real function ulcg(x)
            !-----------------------------------------------------------------------
            !                 Real uniform from linear congruential generator 
            !              ******************************************
            ! Transform sequence of integers generated by the function lcg into uniform distribution
            !
            ! INPUT VARIABLES:
            !   x                64 bit integers generated by function lcg
            !
            ! OUTPUT
            !   real             with uniform distribution in interval ]0,1[
            !-----------------------------------------------------------------------

            ! inputs
            integer(i64), intent(in) :: x
            
            ulcg = real(x)/real(m_lcg)

        end function ulcg

        recursive pure subroutine QSort(na,A,Ind,first, last)
            !-----------------------------------------------------------------------
            !                 Sort inplase an array and its index 
            !              ******************************************
            ! Sorts an array using a recursive implementation of the quick sort 
            ! algorithm. 
            ! This is modified from Gist: https://gist.github.com/t-nissie/479f0f16966925fa29ea
            ! Author: t-nissie
            ! License: GPLv3
            ! modiffied by Adrian Martinez
            !
            ! INPUT VARIABLES:
            !   nd               Number of data (no missing values)
            !
            ! INPUT/OUTPUT VARIABLES:
            !   A                Real. Array of values to sort in place
            !   Ind              Integer. Index to track the original order 
            !-----------------------------------------------------------------------

            ! inputs
            integer, intent(in) :: na 
            integer, intent(in) :: first, last
            real, dimension(na), intent(inout) :: A    ! array value
            integer, dimension(na), intent(inout) :: Ind ! array index 1,2,3,4...
            
            !internal
            real :: x, t
            integer ::  i, j, ti
          
            x = a( (first+last) / 2 )
            i = first
            j = last
            do
               do while (a(i) < x)
                  i=i+1
               end do
               do while (x < a(j))
                  j=j-1
               end do
               if (i >= j) exit
               t = a(i);  a(i) = a(j);  a(j) = t
               ti = Ind(i);  Ind(i) = Ind(j);  Ind(j) = ti
               i=i+1
               j=j-1
            end do
            if (first < i-1) call QSort(na,A,Ind, first, i-1)
            if (j+1 < last)  call QSort(na,A,Ind, j+1, last)

        end subroutine QSort

        pure subroutine nscore(nd,vr,wt,vrg,prob,ind,ierror)
            !-----------------------------------------------------------------------
            !              Transform Univariate Data to Normal Scores
            !              ******************************************
            ! This subroutibe takes "nd" data "vr(i),i=1,...,nd" possibly weighted
            ! by "wt(i),i=,...,nd" and returns the normal scores transform N(0,1)
            ! as "vrg(i),i=1,...,nd".  The extra storage array "tmp" is required
            ! so that the data can be returned in the same order (just in case
            ! there are associated arrays like the coordinate location).
            !
            ! INPUT VARIABLES:
            !   nd               Number of data (no missing values)
            !   vr(nd)           Data values to be transformed          
            !   wt(nd)           Weight for each data (don't have to sum to 1.0)
            !                    this is an optional variable, if present will use it, 
            !                    otherwise will use equal weighted                   
            !
            ! OUTPUT VARIABLES:
            !   vrg(nd)          normal scores
            !   prob(nd)         probability
            !   ind(nd)          order of the list sorted
            !   ierror           error flag (0=error free,1=problem)
            !
            ! EXTERNAL REFERENCES:
            
            !   gauinv           Calculates the inverse of a Gaussian cdf
            !   Qsort            sorts a number of arrays in ascending order
            !-----------------------------------------------------------------------

            ! inputs
            integer, intent(in) :: nd 
            real, intent(in), dimension(nd) :: vr 
            real, intent(in), dimension(nd), optional :: wt

            !output 
            real, intent(out), dimension(nd) :: vrg, prob
            integer, intent(out), dimension(nd) :: ind
            integer, intent(out) :: ierror


            ! internal variables
            real, dimension(nd) :: vra
            real   :: twt, oldcp, cp
            integer :: i 

            ! Sort the data in ascending order and calculate total weight:
        
            ierror = 0
            twt    = 0.0
            do i=1,nd
                ! initialize internal copy of the variable, weight and index
                ind(i) = i
                vra(i) = vr(i)
                if(present(wt)) then
                    prob(i) = wt(i)
                    twt = twt + wt(i)  ! total weight
                else
                    prob(i) = 1
                    twt = twt + 1.
                end if
            end do
            if(nd < 1 .OR. twt < EPSLON) then
                ierror = 1
                return
            end if

            call QSort(nd, vra, ind, 1, nd)

            ! Compute the cumulative probabilities:
        
            oldcp = 0.0
            cp    = 0.0
            do i=1,nd
                cp     =  cp + prob(ind(i)) / twt   !prob of interval ind(i), the last point
                prob(ind(i))  = (cp + oldcp)/ 2.0        !prob of mid interval ind(i-1) - ind(i)
                oldcp  =  cp                       !prob of interval ind(i-1), the last point of previous iteration
                call gauinv(dble(prob(ind(i))),vrg(ind(i)),ierror)
                if (ierror>0) return
            end do
            
        end subroutine nscore

        pure subroutine gauinv(p,xp,ierror)
            !-----------------------------------------------------------------------
            ! Computes the inverse of the standard normal cumulative distribution
            ! function with a numerical approximation from : Statistical Computing,
            ! by W.J. Kennedy, Jr. and James E. Gentle, 1980, p. 95.
            !
            ! INPUT/OUTPUT:
            !   p    = double precision cumulative probability value: dble(psingle)
            !   xp   = G^-1 (p) in single precision
            !   ierr = 1 - then error situation (p out of range), 0 - OK
            !-----------------------------------------------------------------------
            ! inputs
            real*8, intent (in) :: p
            

            ! output
            real, intent (out) :: xp
            integer, intent (out) :: ierror

            ! internal variables
            real*8 :: y,pp
            real*8, parameter ::  lim=1.0e-10
            real*8, parameter ::  p0 = -0.322232431088, p1 = -1.0, p2=-0.342242088547
            real*8, parameter ::  p3 = -0.0204231210245, p4 = -0.0000453642210148
            real*8, parameter ::  q0 = 0.0993484626060, q1 = 0.588581570495, q2 = 0.531103462366
            real*8, parameter ::  q3 = 0.103537752850, q4 = 0.0038560700634
            
        
            ! Check for an error situation:
        
            ierror = 1
            if(p < lim) then
                xp = -1.0e10
                return
            end if
            if(p > (1.0-lim)) then
                xp =  1.0e10
                return
            end if
            ierror = 0
        
            ! Get k for an error situation:
        
            pp   = p
            if(p > 0.5) pp = 1 - pp
            xp   = 0.0
            if(p == 0.5) return
        
            ! Approximate the function:
        
            y  = dsqrt(dlog(1.0/(pp*pp)))
            
            xp = real( y + ((((y*p4+p3)*y+p2)*y+p1)*y+p0) / ((((y*q4+q3)*y+q2)*y+q1)*y+q0) )
            
            if(real(p) == real(pp)) xp = -xp
        
        end subroutine gauinv

        pure real function backtr(vrgs,nt,vr,vrg,zmin,zmax,ltail,ltpar, utail,utpar)
            !-----------------------------------------------------------------------
            !           Back Transform Univariate Data from Normal Scores
            !           *************************************************
            ! This subroutine backtransforms a standard normal deviate from a
            ! specified back transform table and option for the tails of the
            ! distribution.  Call once with "first" set to true then set to false
            ! unless one of the options for the tail changes.

            ! INPUT VARIABLES:
            !   vrgs             normal score value to be back transformed
            !   nt               number of values in the back transform tbale
            !   vr(nt)           original data values that were transformed
            !   vrg(nt)          the corresponding transformed values
            !   zmin,zmax        limits possibly used for linear or power model
            !   ltail            option to handle values less than vrg(1):
            !   ltpar            parameter required for option ltail
            !   utail            option to handle values greater than vrg(nt):
            !   utpar            parameter required for option utail
            !
            !-----------------------------------------------------------------------

            ! inputs
            integer, intent (in) :: nt, ltail, utail
            real, dimension(nt), intent (in) ::  vr, vrg
            real, intent (in) ::    ltpar, utpar, vrgs, zmin,zmax

            ! internal variables
            real :: lambda, cdflo, cdfbt, cpow, cdfhi
            integer :: j

            ! Value in the lower tail?    1=linear, 2=power, (3 and 4 are invalid)

            if(vrgs <= vrg(1)) then
                backtr = vr(1)
                cdflo  = gcum(vrg(1))
                cdfbt  = gcum(vrgs)
                if(ltail == CDF_TAIL_LINEAR) then
                    backtr = powint(0.0,cdflo,zmin,vr(1),cdfbt,1.0)
                else if(ltail == CDF_TAIL_POWER) then
                    cpow   = 1.0 / ltpar
                    backtr = powint(0.0,cdflo,zmin,vr(1),cdfbt,cpow)
                endif
            
            ! Value in the upper tail?     1=linear, 2=power, 4=hyperbolic:
            
            else if(vrgs >= vrg(nt)) then
                backtr = vr(nt)
                cdfhi  = gcum(vrg(nt))
                cdfbt  = gcum(vrgs)
                if(utail == CDF_TAIL_LINEAR) then
                    backtr = powint(cdfhi,1.0,vr(nt),zmax,cdfbt,1.0)
                else if(utail == CDF_TAIL_POWER) then
                    cpow   = 1.0 / utpar
                    backtr = powint(cdfhi,1.0,vr(nt),zmax,cdfbt,cpow)
                else if(utail == CDF_TAIL_HYPERBOLIC) then
                    lambda = (vr(nt)**utpar)*(1.0-gcum(vrg(nt)))
                    backtr = (lambda/(1.0-gcum(vrgs)))**(1.0/utpar)
                endif
            else
            
            ! Value within the transformation table:
            
                j = locate(vrg,nt,1,nt,vrgs)
                j = max(min((nt-1),j),1)
                backtr = powint(vrg(j),vrg(j+1),vr(j),vr(j+1),vrgs,1.0)

            endif

        end function backtr

        pure elemental real function gcum(x)
            !-----------------------------------------------------------------------
            ! Evaluate the standard normal cdf given a normal deviate x.  gcum is
            ! the area under a unit normal curve to the left of x.  The results are
            ! accurate only to about 5 decimal places.
            !-----------------------------------------------------------------------

            !inputs
            real, intent(in) :: x

            !internal variables
            real :: z, t, e2

            z = x
            if(z < 0.) z = -z
            t    = 1./(1.+ 0.2316419*z)
            gcum = t*(0.31938153   + t*(-0.356563782 + t*(1.781477937 + &
            t*(-1.821255978 + t*1.330274429))))
            e2   = 0.
        
            !  6 standard deviations out gets treated as infinity:
        
            if(z <= 6.) e2 = exp(-z*z/2.)*0.3989422803
            gcum = 1.0- e2 * gcum
            if(x >= 0.) return
            gcum = 1.0 - gcum
            
        end function gcum


        pure elemental real function powint(xlow,xhigh,ylow,yhigh,xval,pow)
            !-----------------------------------------------------------------------
            ! Power interpolate the value of y between (xlow,ylow) and (xhigh,yhigh)
            !                 for a value of x and a power pow.
            !-----------------------------------------------------------------------

            ! input variables
            real, intent(in) :: xlow, xhigh, ylow, yhigh, xval, pow
        
            if((xhigh-xlow) < EPSLON) then
                powint = (yhigh+ylow)/2.0
            else
                powint = ylow + (yhigh-ylow)*(((xval-xlow)/(xhigh-xlow))**pow)
            end if
        
        end function powint


        pure elemental real*8 function dpowint(xlow,xhigh,ylow,yhigh,xval,pow)
            !-----------------------------------------------------------------------
            ! Power interpolate the value of y between (xlow,ylow) and (xhigh,yhigh)
            !                 for a value of x and a power pow.
            !-----------------------------------------------------------------------

            ! input variables
            real*8, intent(in) :: xlow, xhigh, ylow, yhigh, xval, pow
        
            if((xhigh-xlow) < EPSLON) then
                dpowint = (yhigh+ylow)/2.0
            else
                dpowint = ylow + (yhigh-ylow)*(((xval-xlow)/(xhigh-xlow))**pow)
            end if
        
        end function dpowint 

        pure integer function locate(xx,n,is,ie,x) result(j)
            !-----------------------------------------------------------------------
            ! Given an array "xx" of length "n", and given a value "x", this routine
            ! returns a value "j" such that "x" is between xx(j) and xx(j+1).  xx
            ! must be monotonic, either increasing or decreasing.  j=is-1 or j=ie is
            ! returned to indicate that x is out of range.
            !
            ! Bisection Concept From "Numerical Recipes", Press et. al. 1986  pp 90.
            !-----------------------------------------------------------------------
            
            ! input variables
            integer, intent (in):: n, is, ie
            real, intent (in) :: x
            real, intent (in), dimension(n) :: xx

            !internal variable
            integer :: jl, ju, jm, iss
            
            ! make internal copy of is
            iss = is

            ! Initialize lower and upper methods:
            
            if(iss <= 0) iss = 1
            jl = is-1
            ju = ie
            if(xx(n) <= x) then
                j = ie
                return
            end if
            
            ! If we are not done then compute a midpoint:
            
            10 if(ju-jl > 1) then
                jm = (ju+jl)/2
            
                ! Replace the lower or upper limit with the midpoint:
            
                if((xx(ie) > xx(iss)).eqv.(x > xx(jm))) then
                    jl = jm
                else
                    ju = jm
                endif
                go to 10
            endif
        
            ! Return with the array index:
        
            j = jl

            return
    
        end function locate


        pure integer function dlocate(xx,n,is,ie,x) result(j)
            !-----------------------------------------------------------------------
            ! Given an array "xx" of length "n", and given a value "x", this routine
            ! returns a value "j" such that "x" is between xx(j) and xx(j+1).  xx
            ! must be monotonic, either increasing or decreasing.  j=is-1 or j=ie is
            ! returned to indicate that x is out of range.
            !
            ! Bisection Concept From "Numerical Recipes", Press et. al. 1986  pp 90.
            !-----------------------------------------------------------------------
            
            ! input variables
            integer, intent (in):: n, is, ie
            real*8, intent (in) :: x
            real*8, intent (in), dimension(n) :: xx

            !internal variable
            integer :: jl, ju, jm, iss
            
            ! make internal copy of is
            iss = is

            ! Initialize lower and upper methods:
            
            if(iss <= 0) iss = 1
            jl = is-1
            ju = ie
            if(xx(n) <= x) then
                j = ie
                return
            end if
            
            ! If we are not done then compute a midpoint:
            
            10 if(ju-jl > 1) then
                jm = (ju+jl)/2
            
                ! Replace the lower or upper limit with the midpoint:
            
                if((xx(ie) > xx(iss)).eqv.(x > xx(jm))) then
                    jl = jm
                else
                    ju = jm
                endif
                go to 10
            endif
            
            ! Return with the array index:
        
            j = jl

            return
        
        end function dlocate

            
        pure real function beyond_cdf(nccut,ccut,ccdf,ncut,cut,cdf,zmin,zmax, &
            ltail,ltpar,middle,mpar,utail,utpar, zval)
            !-----------------------------------------------------------------------
            !                     Go Beyond a Discrete CDF
            !                     ************************
            ! This function extrapolate beyond discrete points on a conditional CDF.  It computes 
            ! the corresponding CDF value.
            ! Nan is returned if there is an error 

            ! INPUT/OUTPUT VARIABLES:                
            !   nccut            number of cutoffs defining the conditional CDF
            !   ccut()           real array of the nccut cutoffs
            !   ccdf()           real array of the conditional cdf values
            !   ncut             number of cutoffs defining the global CDF
            !   cut()            real array of the ncut cutoffs
            !   cdf()            real array of the global cdf values
            !   zmin,zmax        minimum and maximum allowable data values
            !   ltail            option to handle values in lower tail
            !   ltpar            parameter required for option ltail
            !   middle           option to handle values in the middle
            !   mpar             parameter required for option middle
            !   utail            option to handle values in upper tail
            !   utpar            parameter required for option utail
            !   output variables
            !   zval             z value corresponding to the cdf value to be computed
            !-----------------------------------------------------------------------
            
            ! Input variables
            integer, intent (in) :: nccut, ncut
            real, intent (in), dimension (ncut):: ccut, ccdf
            real, intent (in), dimension (1):: cut, cdf       !consider using scalar here
            real, intent (in):: zmin, zmax, ltpar, utpar, mpar, zval
            integer, intent (in):: ltail, middle, utail
            

            !  Internal variables
            integer ::   cclow,cchigh, ipart, idat, iupp, ilow
            real ::  powr, temp, lambda
        
            ! Figure out what part of distribution: ipart = 0 - lower tail
            !                                       ipart = 1 - middle
            !                                       ipart = 2 - upper tail

            ipart = 1
            if(zval <= ccut(1))       ipart = 0
            if(zval >= ccut(nccut))   ipart = 2
        
            ! ARE WE IN THE LOWER TAIL?

            if(ipart == 0) then
                if(ltail == CDF_TAIL_LINEAR) then
                
                    ! Straight Linear Interpolation:
                
                    powr = 1.0
                    beyond_cdf = powint(zmin,ccut(1),0.0,ccdf(1),zval,powr)
   
                else if(ltail == CDF_TAIL_POWER) then
                
                    ! Power Model interpolation to lower limit "zmin"?
                
                    beyond_cdf = powint(zmin,ccut(1),0.0,ccdf(1),zval,ltpar)
       
                    ! Linear interpolation between the rescaled global cdf?
                
                else if(ltail == CDF_TAIL_TABULATED) then

                    ! Computing the cdf value. Locate the point and the class bound:
                
                    idat = locate(cut,ncut,1,ncut,zval)
                    iupp = locate(cut,ncut,1,ncut,ccut(1))
                
                    ! Straight linear interpolation if no data; otherwise, linear:
                
                    if(idat <= 0 .OR. idat >= ncut .OR. &
                    iupp <= 0 .OR. iupp >= ncut) then
                        beyond_cdf = powint(zmin,cut(1),0.0,cdf(1),zval,1.)
                    else
                        temp   = powint(cut(idat),cut(idat+1),cdf(idat),cdf(idat+1),zval,1.)
                        beyond_cdf = temp*ccdf(1)/cdf(iupp)
                    endif
                    
                else
                    ! Error situation - unacceptable option, return nan
                    beyond_cdf = ieee_value(beyond_cdf,ieee_quiet_nan)
                    return
                endif
            endif
        
            ! FINISHED THE LOWER TAIL,  ARE WE IN THE MIDDLE?
        
            if(ipart == 1) then
            
                ! Establish the lower and upper limits:
            
                cclow = locate(ccut,nccut,1,nccut,zval)
                
                cchigh = cclow + 1
                if(middle == CDF_TAIL_LINEAR) then
                
                    ! Straight Linear Interpolation:
                
                    powr = 1.0
                    beyond_cdf = powint(ccut(cclow),ccut(cchigh),ccdf(cclow),ccdf(cchigh),zval,powr)

                    ! Power interpolation between class bounds?
                
                else if(middle == CDF_TAIL_POWER) then

                    beyond_cdf = powint(ccut(cclow),ccut(cchigh),ccdf(cclow),ccdf(cchigh),zval,mpar)
                
                    ! Linear interpolation between the rescaled global cdf?
                
                else if(middle == CDF_TAIL_TABULATED) then
                    ilow = locate(cut,ncut,1,ncut,ccut(cclow))
                    iupp = locate(cut,ncut,1,ncut,ccut(cchigh))
                    if(cut(ilow) < ccut(cclow))  ilow = ilow + 1
                    if(cut(iupp) > ccut(cchigh)) iupp = iupp - 1

                    idat = locate(cut,ncut,1,ncut,zval)
                
                    ! Straight linear interpolation if no data; otherwise, local linear
                    ! interpolation:
                
                    if(idat <= 0 .OR. idat >= ncut .OR. ilow <= 0 .OR. ilow >= ncut .OR. &
                       iupp <= 0 .OR. iupp >= ncut .OR. iupp <= ilow) then         
                        beyond_cdf=powint(ccut(cclow),ccut(cchigh),ccdf(cclow),ccdf(cchigh),zval,1.)
                    else
                        temp = powint(cut(idat),cut(idat+1),cdf(idat),cdf(idat+1),zval,1.)
                        beyond_cdf=powint(cdf(ilow),cdf(iupp),ccdf(cclow),ccdf(cchigh),temp,1.)
                    endif
                    
                else
                    ! Error situation - unacceptable option, return nan
                    beyond_cdf = ieee_value(beyond_cdf,ieee_quiet_nan)
                    return
                endif
            endif
        
            ! FINISHED THE MIDDLE,  ARE WE IN THE UPPER TAIL?
        
            if(ipart == 2) then
                if(utail == CDF_TAIL_LINEAR) then
                    
                    powr = 1.0
                    beyond_cdf = powint(ccut(nccut),zmax,ccdf(nccut), 1.0,zval,powr)
        
                else if(utail == CDF_TAIL_POWER) then
                
                    ! Power interpolation to upper limit "utpar"?
                
                    beyond_cdf = powint(ccut(nccut),zmax,ccdf(nccut),1.0,zval,utpar)

                    ! Linear interpolation between the rescaled global cdf?
                
                else if(utail == CDF_TAIL_TABULATED) then

                    ! Approximately Locate the point and the class bound:
                
                    idat = locate(cut,ncut,1,ncut,zval)
                    ilow = locate(cut,ncut,1,ncut,ccut(nccut))
                    if(cut(idat) < zval)        idat = idat + 1
                    if(cut(ilow) < ccut(nccut)) ilow = ilow + 1
                
                    ! Straight linear interpolation if no data; otherwise, local linear
                    ! interpolation:
                
                    if(idat <= 0 .OR. idat >= ncut .OR. ilow <= 0 .OR. ilow >= ncut) then
                        beyond_cdf = powint(ccut(nccut),zmax,ccdf(nccut),1.0,zval,1.)
                    else
                        temp   = powint(cut(idat),cut(idat+1),cdf(idat),cdf(idat+1),zval,1.)
                        beyond_cdf = powint(cdf(ilow),1.0, ccdf(nccut),1.0,temp,1.)
                    endif

                    ! Fit a Hyperbolic Distribution?
                
                else if(utail == CDF_TAIL_HYPERBOLIC) then
                
                    ! Figure out "lambda" and required info:
                
                    lambda = (ccut(nccut)**utpar)*(1.0-ccdf(nccut))
                    beyond_cdf = 1.0 - (lambda/(zval**utpar))

                else
                    ! Error situation - unacceptable option, return nan
                    beyond_cdf = ieee_value(beyond_cdf,ieee_quiet_nan)
                    return
                endif
            endif

            ! All finished - return:
        
            return
        
        end function beyond_cdf


        pure real function beyond_zval(ivtype,nccut,ccut,ccdf,ncut,cut,cdf,zmin,zmax, &
            ltail,ltpar,middle,mpar,utail,utpar,cdfval)
            !-----------------------------------------------------------------------
            !                     Go Beyond a Discrete CDF
            !                     ************************
            ! This function interpolate the CDF value "zval" within and extrapolate  
            ! beyond discrete points on a conditional CDF.  
            ! returns nan if there is an error
            !
            ! INPUT/OUTPUT VARIABLES:                
            !   ivtype           variable type (1=continuous, 0=categorical)
            !   nccut            number of cutoffs defining the conditional CDF
            !   ccut()           real array of the nccut cutoffs
            !   ccdf()           real array of the conditional cdf values
            !   ncut             number of cutoffs defining the global CDF
            !   cut()            real array of the ncut cutoffs
            !   cdf()            real array of the global cdf values
            !   zmin,zmax        minimum and maximum allowable data values
            !   ltail            option to handle values in lower tail
            !   ltpar            parameter required for option ltail
            !   middle           option to handle values in the middle
            !   mpar             parameter required for option middle
            !   utail            option to handle values in upper tail
            !   utpar            parameter required for option utail
            !   cdfval           cdf value corresponding to the z value to be computed
            !-----------------------------------------------------------------------
            
            ! Input variables
            integer, intent (in) :: ivtype, nccut, ncut
            real, intent (in), dimension (ncut):: ccut, ccdf
            real, intent (in), dimension (1):: cut, cdf       !consider using scalar here
            real, intent (in):: zmin, zmax, ltpar, utpar, mpar, cdfval 
            integer, intent (in):: ltail, middle, utail
            

            !  Internal variables
            integer ::   cclow,cchigh, i, ipart, idat, iupp, ilow
            real :: cum, powr, temp, lambda
        
            ! Check for both "zval" and "cdfval" defined or undefined:

            ! return nan if the cdf is not valid
            if(cdfval < 0. .or. cdfval > 1.) then 
                beyond_zval = ieee_value(beyond_zval,ieee_quiet_nan)
                return
            end if

            ! Handle the case of a categorical variable:
        
            if(ivtype == VARTYPE_CATEGORICAL) then
                cum = 0
                do i=1,nccut
                    cum = cum + ccdf(i)
                    if(cdfval <= cum) then
                        beyond_zval = ccut(i)
                        return
                    endif
                end do
                return
            end if
        
            ! Figure out what part of distribution: ipart = 0 - lower tail
            !                                       ipart = 1 - middle
            !                                       ipart = 2 - upper tail
            ipart = 1
            if(cdfval <= ccdf(1))     ipart = 0
            if(cdfval >= ccdf(nccut)) ipart = 2
            
        
            ! ARE WE IN THE LOWER TAIL?
        
            if(ipart == 0) then
                if(ltail == CDF_TAIL_LINEAR) then
                
                    ! Straight Linear Interpolation:
                
                    powr = 1.0
                    beyond_zval = powint(0.0,ccdf(1),zmin,ccut(1), cdfval,powr)
                    
                else if(ltail == CDF_TAIL_POWER) then
                
                    ! Power Model interpolation to lower limit "zmin"?

                    powr = 1.0 / ltpar
                    beyond_zval = powint(0.0,ccdf(1),zmin,ccut(1),cdfval,powr)
                    
                
                    ! Linear interpolation between the rescaled global cdf?
                
                else if(ltail == CDF_TAIL_TABULATED) then
                                      
                    ! Computing Z value: Are there any data out in the tail?
                
                    iupp = locate(cut,ncut,1,ncut,ccut(1))
                
                    ! Straight linear interpolation if no data; otherwise, local linear
                    ! interpolation:
                
                    if(iupp <= 0 .OR. iupp >= ncut) then
                        beyond_zval = powint(0.0,cdf(1),zmin,cut(1),cdfval,1.)
                    else
                        temp = cdfval*cdf(iupp)/ccdf(1)
                        idat = locate(cdf,ncut,1,ncut,temp)
                        if(idat <= 0 .OR. idat >= ncut) then
                            beyond_zval = powint(0.0,cdf(1),zmin, cut(1),cdfval,1.)
                        else
                            beyond_zval = powint(cdf(idat),cdf(idat+1),cut(idat),cut(idat+1),temp,1.)
                        end if
                    endif
                    
                else
                    ! Error situation - unacceptable option, returns nan
                    beyond_zval = ieee_value(beyond_zval,ieee_quiet_nan)
                    return
                endif
            endif
        
            ! FINISHED THE LOWER TAIL,  ARE WE IN THE MIDDLE?
        
            if(ipart == 1) then
            
                ! Establish the lower and upper limits:
                
                cclow = locate(ccdf,nccut,1,nccut,cdfval)
                cchigh = cclow + 1

                if(middle == CDF_TAIL_LINEAR) then
                
                    ! Straight Linear Interpolation:
                
                    powr = 1.0
                    beyond_zval = powint(ccdf(cclow),ccdf(cchigh),ccut(cclow),ccut(cchigh),cdfval,powr)
                
                    ! Power interpolation between class bounds?
                
                else if(middle == CDF_TAIL_POWER) then
       
                    powr = 1.0 / mpar
                    beyond_zval = powint(ccdf(cclow),ccdf(cchigh),ccut(cclow),ccut(cchigh),cdfval,powr)
                
                    ! Linear interpolation between the rescaled global cdf?
                
                else if(middle == CDF_TAIL_TABULATED) then
                    ilow = locate(cut,ncut,1,ncut,ccut(cclow))
                    iupp = locate(cut,ncut,1,ncut,ccut(cchigh))
                    if(cut(ilow) < ccut(cclow))  ilow = ilow + 1
                    if(cut(iupp) > ccut(cchigh)) iupp = iupp - 1
                
                
                    ! Straight linear interpolation if no data; otherwise, local linear
                    ! interpolation:
                
                    if(ilow <= 0 .OR. ilow >= ncut .OR. &
                    iupp <= 0 .OR. iupp >= ncut .OR. &
                    iupp <= ilow) then
                        beyond_zval=powint(ccdf(cclow),ccdf(cchigh),ccut(cclow),ccut(cchigh),cdfval,1.)
                    else
                        temp=powint(ccdf(cclow),ccdf(cchigh),cdf(ilow),cdf(iupp),cdfval,1.)
                        idat = locate(cdf,ncut,1,ncut,temp)
                        if(cut(idat) < ccut(cclow)) idat=idat+1
                        if(idat <= 0 .OR. idat >= ncut .OR. cut(idat+1) > ccut(cchigh)) then
                            beyond_zval = powint(ccdf(cclow),ccdf(cchigh),ccut(cclow),ccut(cchigh),cdfval,1.)
                        else
                            beyond_zval = powint(cdf(idat),cdf(idat+1),cut(idat),cut(idat+1),temp,1.)
                        end if
                        beyond_zval = powint(cdf(idat),cdf(idat+1),cut(idat),cut(idat+1),temp,1.)
                    endif
                else
                    ! Error situation - unacceptable option, returns nan
                    beyond_zval = ieee_value(beyond_zval,ieee_quiet_nan)
                    return
                endif
            endif
        
            ! FINISHED THE MIDDLE,  ARE WE IN THE UPPER TAIL?
        
            if(ipart == 2) then
                if(utail == CDF_TAIL_LINEAR) then
                    powr = 1.0
                    beyond_zval = powint(ccdf(nccut),1.0,ccut(nccut), zmax,cdfval,powr)
        
                else if(utail == CDF_TAIL_POWER) then
                
                    ! Power interpolation to upper limit "utpar"?
   
                    powr = 1.0 / utpar
                    beyond_zval = powint(ccdf(nccut),1.0,ccut(nccut),zmax,cdfval,powr)
                
                    ! Linear interpolation between the rescaled global cdf?
                
                else if(utail == CDF_TAIL_TABULATED) then
                
                
                    ! Computing Z value: Are there any data out in the tail?
                
                    ilow = locate(cut,ncut,1,ncut,ccut(nccut))
                    if(cut(ilow) < ccut(nccut)) ilow = ilow + 1
                
                    ! Straight linear interpolation if no data; otherwise, local linear
                    ! interpolation:
                
                    if(ilow <= 0 .OR. ilow >= ncut) then
                        beyond_zval = powint(ccdf(nccut),1.0,ccut(nccut),zmax,cdfval,1.)
                    else
                        temp = powint(ccdf(nccut),1.0, &
                        cdf(ilow),1.0,cdfval,1.)
                        idat = locate(cdf,ncut,1,ncut,temp)
                        if(cut(idat) < ccut(nccut)) idat=idat+1
                        if(idat >= ncut) then
                            beyond_zval = powint(ccdf(nccut),1.0,ccut(nccut),zmax,cdfval,1.)
                        else
                            beyond_zval = powint(cdf(idat),cdf(idat+1),cut(idat),cut(idat+1),temp,1.)
                        endif
                    endif
                
                    ! Fit a Hyperbolic Distribution?
                
                else if(utail == CDF_TAIL_HYPERBOLIC) then
                
                    ! Figure out "lambda" and required info:
                
                    lambda = (ccut(nccut)**utpar)*(1.0-ccdf(nccut))
                    beyond_zval = (lambda/(1.0-cdfval))**(1.0/utpar)

                else
                    ! Error situation - unacceptable option, returns nan
                    beyond_zval = ieee_value(beyond_zval,ieee_quiet_nan)
                    return
                endif
            endif
            if(beyond_zval < zmin) beyond_zval = zmin
            if(beyond_zval > zmax) beyond_zval = zmax
        
            ! All finished - return:
        
            return
        
        end function beyond_zval

        pure real*8 function sqdist(x1,y1,z1,x2,y2,z2,ind,nrotmat,rotmat)
            !-----------------------------------------------------------------------
            !    Squared Anisotropic Distance Calculation Given Matrix Indicator
            !    ***************************************************************
            !
            !  This routine calculates the anisotropic distance between two points
            !  given the coordinates of each point and a definition of the
            !  anisotropy.
            !
            ! INPUT VARIABLES:
            !
            !   x1,y1,z1         Coordinates of first point
            !   x2,y2,z2         Coordinates of second point
            !   ind              The rotation matrix to use
            !   nrotmat          The maximum number of rotation matrices dimensioned
            !   rotmat           The rotation matrices
            !
            ! OUTPUT VARIABLES:
            !   sqdist           The squared distance accounting for the anisotropy
            !                      and the rotation of coordinates (if any).
            !
            !   sqdist is nan  MEANS ERROR 
            !
            ! NO EXTERNAL REFERENCES
            !-----------------------------------------------------------------------

            ! input variables variables
            integer, intent(in) :: nrotmat, ind 
            real*8, intent(in), dimension(nrotmat,3,3) :: rotmat
            real, intent(in) :: x1,y1,z1, x2,y2, z2

            ! internal variables
            real*8 :: cont,dx,dy,dz
            integer :: i
            ! Compute component distance vectors and the squared distance:

            if (nrotmat < ind) then
                ! set to nan
                sqdist = ieee_value(sqdist, ieee_quiet_nan)
                return
            end if

            dx = dble(x1 - x2)
            dy = dble(y1 - y2)
            dz = dble(z1 - z2)
            sqdist = 0.0
            do i=1,3
                cont   = rotmat(ind,i,1) * dx &
                       + rotmat(ind,i,2) * dy &
                       + rotmat(ind,i,3) * dz
                sqdist = sqdist + cont * cont
            end do
            return
        end function sqdist

        pure real function cova3(x1,y1,z1,x2,y2,z2,ivarg,nst,c0,it,cc,aa, irot,nrotmat,rotmat, d)
            !-----------------------------------------------------------------------
            !                    Covariance Between Two Points
            !                    *****************************
            ! This subroutine calculated the covariance associated with a variogram
            ! model specified by a nugget effect and nested varigoram structures.
            ! The anisotropy definition can be different for each nested structure.
            !
            ! INPUT VARIABLES:
            !   x1,y1,z1         coordinates of first point
            !   x2,y2,z2         coordinates of second point
            !   nst              number of nested structures
            !   ivarg            variogram number (set to 1 unless doing cokriging
            !                       or indicator kriging)
            !   c0(ivarg)        isotropic nugget constant
            !   it(i)            type of each nested structure:
            !                      1. spherical model of range a;
            !                      2. exponential model of parameter a;
            !                           i.e. practical range is 3a
            !                      3. gaussian model of parameter a;
            !                           i.e. practical range is a*sqrt(3)
            !                      4. power model of power a (a must be gt. 0  and
            !                           lt. 2).  if linear model, a=1,c=slope.
            !                      5. hole effect model
            !   cc(i)            multiplicative factor of each nested structure.
            !                      (sill-c0) for spherical, exponential,and gaussian
            !                      slope for linear model.
            !   aa(i)            parameter "a" of each nested structure.
            !   irot             index of the rotation matrix for the first nested
            !                    structure (the second nested structure will use
            !                    irot+1, the third irot+2, and so on)
            !   nrotmat          size of rotation matrix arrays
            !   rotmat           rotation matrices
            !
            ! OUTPUT VARIABLES:
            !   cmax             maximum covariance
            !   cova             covariance between (x1,y1,z1) and (x2,y2,z2)
            !
            ! EXTERNAL REFERENCES: sqdist    computes anisotropic squared distance
            !                      rotmat    computes rotation matrix for distance
            !
            ! Change from old code:
            !    -nst is now a sclar instead of an array, and all the variograms will 
            !     have the same number of structures (nst). The sise of the arrays 
            !     is nst*ivarg
            !    -size of the rotation matrix renemed to nrotmat
            !    -removed output cmax, which is not used in any other gslib program
            !    -turned cova3 into function
            !    -parameter d for damped hole effect added
            !-----------------------------------------------------------------------
            
            ! input variables
            real, intent(in) :: x1,y1,z1,x2,y2,z2          ! coordinates of the two points
            integer, intent(in) :: ivarg, irot, nst, nrotmat                  
            real, intent(in), dimension(ivarg) ::c0
            real, intent(in), dimension(nst*ivarg) :: cc,aa
            integer, intent(in), dimension(nst*ivarg) :: it
            real*8, intent(in), dimension(nrotmat,3,3) :: rotmat
            real, intent(in), optional :: d
            
            ! internal variables
            real*8 :: hsqd
            real :: cmax, h, hr
            integer :: istart, is, ist, ir
            
        
            ! Calculate the maximum covariance value (used for zero distances and
            ! for power model covariance):
        
            istart = 1 + (ivarg-1)*nrotmat
            cmax   = c0(ivarg)
            do is=1,nst
                ist = istart + is - 1
                if(it(ist) == COV_POWER) then
                    cmax = cmax + PMX
                else
                    cmax = cmax + cc(ist)
                endif
            end do
        
            ! Check for "zero" distance, return with cmax if so:
        
            hsqd = sqdist(x1,y1,z1,x2,y2,z2,irot,nrotmat,rotmat)
            if (ieee_is_nan(hsqd)) then
                cova3 = ieee_value(cova3,ieee_quiet_nan)
                return
            end if
            if(real(hsqd) < EPSLON) then
                cova3 = cmax
                return
            end if
        
            ! Loop over all the structures:
        
            cova3 = 0.0
            do is=1,nst
                ist = istart + is - 1
            
                ! Compute the appropriate distance:
                if(ist /= 1) then
                    ir = min((irot+is-1),nrotmat)
                    hsqd=sqdist(x1,y1,z1,x2,y2,z2,ir,nrotmat,rotmat)
                end if
                h = real(dsqrt(hsqd))
            
                ! Spherical Variogram Model?
                if(it(ist) == COV_SPHERICAL) then
                    hr = h/aa(ist)
                    if(hr < 1.) cova3=cova3+cc(ist)*(1.-hr*(1.5-.5*hr*hr))
                
                ! Exponential Variogram Model?
                else if(it(ist) == COV_EXPONENTIAL) then
                    cova3 = cova3 + cc(ist)*exp(-3.0*h/aa(ist))
                
                ! Gaussian Variogram Model?
                else if(it(ist) == COV_GAUSSIAN) then
                    cova3 = cova3 + cc(ist)*exp(-3.*(h/aa(ist))*(h/aa(ist)))
                
                ! Power Variogram Model?
                else if(it(ist) == COV_POWER) then
                    cova3 = cova3 + cmax - cc(ist)*(h**aa(ist))
                
                ! Hole Effect Model?
                else if(it(ist) == COV_HOLE_EFFECT) then
                    cova3 = cova3 + cc(ist)*cos(h/aa(ist)*PI)

                ! Damped Hole Effect Model?
                else if(it(ist) == COV_DAMP_HOLE_EFFECT) then

                    if(present(d)) then
                        cova3 = cova3 + cc(ist)*exp(-3.0*h/d)*cos(h/aa(ist)*PI)
                    else
                        ! d is the distance where 95% of the hole effect is dampened out. 
                        ! Here we assume d is 10 times the range.
                        cova3 = cova3 + cc(ist)*exp(-3.0*h/(10.0 * aa(ist)))*cos(h/aa(ist)*PI) 
                    end if

                ! TODO: add here Cauchy model, Matern model, Logistic model (rational quadratic model), Generalised Cauchy, Spheroidal
                else
                    cova3 = ieee_value(cova3,ieee_quiet_nan)
                    return
                end if

            end do
        
            ! Finished:
        
        end function cova3


        pure elemental integer function getindx(min,siz,loc) result (index)
            !-----------------------------------------------------------------------
            !     Gets the coordinate index location of a point within a grid
            !     ***********************************************************
            ! min     origin at the center of the first cell
            ! siz     size of the cells
            ! loc     location of the point being considered
            ! index   output index within [1,n]
            !-----------------------------------------------------------------------

            ! inputs 
            real, intent (in) :: min,siz,loc
            
            ! Compute the index of "loc":
            index = int( (loc-min)/siz + 1.5 )
            
        end function getindx
            

        pure subroutine setrot(ang1,ang2,ang3,anis1,anis2,ind,nrotmat,rotmat)
            !-----------------------------------------------------------------------
            !              Sets up an Anisotropic Rotation Matrix
            !              **************************************
            !
            ! Sets up the matrix to transform cartesian coordinates to coordinates
            ! accounting for angles and anisotropy (see manual for a detailed
            ! definition):
            !
            ! INPUT PARAMETERS:
            !   ang1             Azimuth angle for principal direction
            !   ang2             Dip angle for principal direction
            !   ang3             Third rotation angle
            !   anis1            First anisotropy ratio
            !   anis2            Second anisotropy ratio
            !   ind              matrix indicator to initialize
            !   nrotmat          maximum number of rotation matrices dimensioned
            !   rotmat           rotation matrices
            !
            ! Note: all angles are in degrees
            !       matrix set to nan if there is an error nrotmat<ind
            !-----------------------------------------------------------------------

            ! inputs
            integer, intent (in) :: nrotmat, ind
            real, intent (in) :: ang1,ang2,ang3,anis1,anis2

            !output
            real*8, intent (inout), dimension(nrotmat,3,3) :: rotmat

            !internal
            real*8 :: afac1,afac2,sina,sinb,sint, cosa,cosb,cost
            real :: alpha, beta, theta
            
            ! returns nan if ind is not valid
            if(nrotmat<ind) then
                rotmat = ieee_value(rotmat,ieee_quiet_nan)
                return
            end if
            ! Converts the input angles to three angles which make more
            !  mathematical sense:
            
            !         alpha   angle between the major axis of anisotropy and the
            !                 E-W axis. Note: Counter clockwise is positive.
            !         beta    angle between major axis and the horizontal plane.
            !                 (The dip of the ellipsoid measured positive down)
            !         theta   Angle of rotation of minor axis about the major axis
            !                 of the ellipsoid.
            
            if(ang1 >= 0.0 .AND. ang1 < 270.0) then
                alpha = (90.0   - ang1) * DEG2RAD
            else
                alpha = (450.0  - ang1) * DEG2RAD
            endif
            beta  = -1.0 * ang2 * DEG2RAD
            theta =        ang3 * DEG2RAD
            
            ! Get the required sines and cosines:
            
            sina  = dble(sin(alpha))
            sinb  = dble(sin(beta))
            sint  = dble(sin(theta))
            cosa  = dble(cos(alpha))
            cosb  = dble(cos(beta))
            cost  = dble(cos(theta))
            
            ! Construct the rotation matrix in the required memory:
            
            afac1 = 1.0 / dble(max(anis1,EPSLON))
            afac2 = 1.0 / dble(max(anis2,EPSLON))
            rotmat(ind,1,1) =       (cosb * cosa)
            rotmat(ind,1,2) =       (cosb * sina)
            rotmat(ind,1,3) =       (-sinb)
            rotmat(ind,2,1) = afac1*(-cost*sina + sint*sinb*cosa)
            rotmat(ind,2,2) = afac1*(cost*cosa + sint*sinb*sina)
            rotmat(ind,2,3) = afac1*( sint * cosb)
            rotmat(ind,3,1) = afac2*(sint*sina + cost*sinb*cosa)
            rotmat(ind,3,2) = afac2*(-sint*cosa + cost*sinb*sina)
            rotmat(ind,3,3) = afac2*(cost * cosb)
        
        end subroutine setrot

        pure subroutine ordrel_disc(ncut,ccdf,ccdfo,nviol,aviol,xviol)
            !-----------------------------------------------------------------------
            !                 Correct Order Relation Problems on discrete variable CDF
            !                 *******************************
            ! This subroutine identifies and corrects order relation problems in a
            ! conditional distribution known at a specified number of cutoffs.
            !
            ! INPUT VARIABLES:
            !   ncut             number of cutoffs
            !   ccdf(i)          input ccdf values
            !
            ! OUTPUT VARIABLES:
            !   ccdfo            corrected ccdf values
            !   nviol()          number of order relation violations
            !   aviol()          average magnitude of the order relation violations
            !   xviol()          maximum magnitude of the order relation violations
            !
            ! PROGRAMMING NOTES:
            !
            !   1. the arrays ccdf1 and ccdf2 are used for temporary storage of the
            !      ccdf corrected sequentially upwards and downwards.  The program
            !      execution will be stopped if the memory allocation of these two
            !      arrays is not sufficient.
            !-----------------------------------------------------------------------

            ! inputs
            integer, intent(in) :: ncut
            real, intent(in), dimension(ncut) :: ccdf
            
            ! outputs
            real, intent(out), dimension(ncut) :: ccdfo, aviol, xviol
            integer, intent(out), dimension(ncut) :: nviol
            
            ! internals 
            real, dimension(ncut) :: ccdf1, ccdf2
            integer :: i
            real :: sumcdf, viol
        
            ! Make sure conditional cdf is within [0,1]:
            
            do i=1,ncut
                if(ccdf(i) < 0.0) then
                    ccdf1(i) = 0.0
                    ccdf2(i) = 0.0
                else if(ccdf(i) > 1.0) then
                    ccdf1(i) = 1.0
                    ccdf2(i) = 1.0
                else
                    ccdf1(i) = ccdf(i)
                    ccdf2(i) = ccdf(i)
                endif
            end do
            
            ! Correct sequentially up, then down, and then average:
            sumcdf = 0.0
            do i=1,ncut
                sumcdf = sumcdf + ccdf1(i)
            end do
            if(sumcdf <= 0.0) sumcdf = 1.0
            do i=1,ncut
                ccdfo(i) = ccdf1(i) / sumcdf
            end do

            ! Accumulate error statistics:
            nviol = 0
            aviol = 0.
            xviol = 0.
            do i=1,ncut
                if(ccdf(i) /= ccdfo(i)) then
                    viol = abs(ccdf(i)-ccdfo(i))
                    nviol(i) = nviol(i) + 1
                    aviol(i) = aviol(i) + viol
                    xviol(i) = max(xviol(i),viol)
                endif
            end do
            
        end subroutine ordrel_disc


        pure subroutine ordrel_cont(ncut,ccdf,ccdfo,nviol,aviol,xviol)
            !-----------------------------------------------------------------------
            !                 Correct Order Relation Problems on continous variable CDF
            !                 *******************************
            ! This subroutine identifies and corrects order relation problems in a
            ! conditional distribution known at a specified number of cutoffs.
            !
            ! INPUT VARIABLES:
            !   ncut             number of cutoffs
            !   ccdf(i)          input ccdf values
            !
            ! OUTPUT VARIABLES:
            !   ccdfo            corrected ccdf values
            !   nviol()          number of order relation violations
            !   aviol()          average magnitude of the order relation violations
            !   xviol()          maximum magnitude of the order relation violations
            !
            ! PROGRAMMING NOTES:
            !
            !   1. the arrays ccdf1 and ccdf2 are used for temporary storage of the
            !      ccdf corrected sequentially upwards and downwards.  The program
            !      execution will be stopped if the memory allocation of these two
            !      arrays is not sufficient.
            !-----------------------------------------------------------------------

            ! inputs
            integer, intent(in) :: ncut
            real, intent(in), dimension(ncut) :: ccdf
            
            ! outputs
            real, intent(out), dimension(ncut) :: ccdfo, aviol, xviol
            integer, intent(out), dimension(ncut) :: nviol
            
            ! internals 
            real, dimension(ncut) :: ccdf1, ccdf2
            integer :: i
            real :: viol
        
            ! Make sure conditional cdf is within [0,1]:
            
            do i=1,ncut
                if(ccdf(i) < 0.0) then
                    ccdf1(i) = 0.0
                    ccdf2(i) = 0.0
                else if(ccdf(i) > 1.0) then
                    ccdf1(i) = 1.0
                    ccdf2(i) = 1.0
                else
                    ccdf1(i) = ccdf(i)
                    ccdf2(i) = ccdf(i)
                endif
            end do
            
            ! Correct sequentially up, then down, and then average:
            
            do i=2,ncut
                if(ccdf1(i) < ccdf1(i-1)) ccdf1(i) = ccdf1(i-1)
            end do
            do i=ncut-1,1,-1
                if(ccdf2(i) > ccdf2(i+1)) ccdf2(i) = ccdf2(i+1)
            end do
            do i=1,ncut
                ccdfo(i) = 0.5*(ccdf1(i)+ccdf2(i))
            end do

            
            ! Accumulate error statistics:
            nviol = 0
            aviol = 0.
            xviol = 0.
            do i=1,ncut
                if(ccdf(i) /= ccdfo(i)) then
                    viol = abs(ccdf(i)-ccdfo(i))
                    nviol(i) = nviol(i) + 1
                    aviol(i) = aviol(i) + viol
                    xviol(i) = max(xviol(i),viol)
                endif
            end do
            
        end subroutine ordrel_cont

end module gslib
